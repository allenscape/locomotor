// generated by Fast Light User Interface Designer (fluid) version 1.0109

#include "EvolverUI.hpp"
#include <iostream>

void EvolverUI::cb_Load_i(Fl_Menu_*, void*) {
  const char* filename 
	= fl_file_chooser( "Select a NEAT Configuration file.",
			   "*.ne", NULL, 0 );
if( !filename ) return;

  myNeat->is_ready 
	= myNeat->load_neat_params( (char*) filename );
  updateParams();

if( !( myNeat->is_ready ) )
{
	fl_message( "Couldn't read '%s'.", filename );
};
}
void EvolverUI::cb_Load(Fl_Menu_* o, void* v) {
  ((EvolverUI*)(o->parent()->user_data()))->cb_Load_i(o,v);
}

void EvolverUI::cb_Reset_i(Fl_Menu_*, void*) {
  mySim->reset();
}
void EvolverUI::cb_Reset(Fl_Menu_* o, void* v) {
  ((EvolverUI*)(o->parent()->user_data()))->cb_Reset_i(o,v);
}

Fl_Menu_Item EvolverUI::menu_myMenuBar[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Load NEAT Parameters File...", 0,  (Fl_Callback*)EvolverUI::cb_Load, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Reset", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Reset Physics Simulation (Only effects current evaluation)", 0,  (Fl_Callback*)EvolverUI::cb_Reset, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* EvolverUI::myFileMenu = EvolverUI::menu_myMenuBar + 0;

void EvolverUI::cb_myCameraElevationSlider_i(Fl_Roller*, void*) {
  mySimWindow->setCameraElevation( myCameraElevationSlider->value() );
}
void EvolverUI::cb_myCameraElevationSlider(Fl_Roller* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->user_data()))->cb_myCameraElevationSlider_i(o,v);
}

void EvolverUI::cb_myCameraRotationSlider_i(Fl_Roller*, void*) {
  mySimWindow->setCameraRotation( myCameraRotationSlider->value() );
}
void EvolverUI::cb_myCameraRotationSlider(Fl_Roller* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->user_data()))->cb_myCameraRotationSlider_i(o,v);
}

void EvolverUI::cb_myNumRuns_i(Fl_Value_Input*, void*) {
  NEAT::num_runs = myNumRuns->value();
}
void EvolverUI::cb_myNumRuns(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myNumRuns_i(o,v);
}

void EvolverUI::cb_myPopSize_i(Fl_Value_Input*, void*) {
  NEAT::pop_size = myPopSize->value();
}
void EvolverUI::cb_myPopSize(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myPopSize_i(o,v);
}

void EvolverUI::cb_myRandSeed_i(Fl_Value_Input*, void*) {
  srand( myRandSeed->value() );
}
void EvolverUI::cb_myRandSeed(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myRandSeed_i(o,v);
}

void EvolverUI::cb_Set_i(Fl_Button*, void*) {
  const char* filename 
	= fl_file_chooser( "Select an Initial Genome file.",
			   "*.genome", NULL, 0 );
if( !filename ) 
{
	myRunStraightSim->deactivate();
	return;
}

myEvolver->createStartingGenome( mySim->getBody(), filename );
myGenotypeFilename->value( filename );
myRunStraightSim->activate();
}
void EvolverUI::cb_Set(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Set_i(o,v);
}

void EvolverUI::cb_myRunStraightSim_i(Fl_Button*, void*) {
  using namespace Else;

if( !myFitnessFunc )
{
	FitnessFuncFactory lclFFFactory;
	myFitnessFunc = FitnessFuncPtr( lclFFFactory.make( "Walk" ) );
}
	
bool hasHarness = mySingleRunHasHarness->value();
myEvolver->runIndividualGenome( myFitnessFunc, mySim, hasHarness );
}
void EvolverUI::cb_myRunStraightSim(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myRunStraightSim_i(o,v);
}

void EvolverUI::cb_myControllerChoice_i(Fl_Choice*, void*) {
  if( !myEvolver->isRunning() )
{
  Else::EvolverFactory lclFactory;
  const Fl_Menu_Item* sel = myControllerChoice->mvalue();

  myEvolver
    = lclFactory.make( (const char*) sel->user_data(), myNeat );

  std::cout << "Changing to evolver: " << (const char*) sel->user_data() << "\n";
}
else
{
  std::cerr << "Attempt to change Evolver while running ignored.\n";
};
}
void EvolverUI::cb_myControllerChoice(Fl_Choice* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myControllerChoice_i(o,v);
}

Fl_Menu_Item EvolverUI::menu_myControllerChoice[] = {
 {"NEAT", 0,  0, (void*)("NEAT"), 0, FL_NORMAL_LABEL, 0, 12, 0},
 {"Echo State Network", 0,  0, (void*)("CLUMP"), 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void EvolverUI::cb_myDropOffAge_i(Fl_Value_Input*, void*) {
  NEAT::dropoff_age = myDropOffAge->value();
}
void EvolverUI::cb_myDropOffAge(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myDropOffAge_i(o,v);
}

void EvolverUI::cb_myMutationWeight_i(Fl_Value_Input*, void*) {
  NEAT::weight_mut_power = myMutationWeight->value();
}
void EvolverUI::cb_myMutationWeight(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myMutationWeight_i(o,v);
}

void EvolverUI::cb_mySpeciesTarget_i(Fl_Value_Input*, void*) {
  NEAT::num_species_target = mySpeciesTarget->value();
}
void EvolverUI::cb_mySpeciesTarget(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_mySpeciesTarget_i(o,v);
}

void EvolverUI::cb_myLinkWeightMutationProb_i(Fl_Value_Input*, void*) {
  NEAT::mutate_link_weights_prob = myLinkWeightMutationProb->value();
}
void EvolverUI::cb_myLinkWeightMutationProb(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myLinkWeightMutationProb_i(o,v);
}

void EvolverUI::cb_Apply_i(Fl_Button*, void*) {
  mySim->setGravity( myGravity->value() );
mySim->setCFM( myCFM->value() );
mySim->setERP( myERP->value() );
mySim->setUseFastStep( myFastStepToggle->value() == 1 );
mySim->setTimeStep( myTimeStep->value() );
mySim->setFastSubSteps( myFastSubSteps->value() );
mySim->setCollisionERP( myCollisionERP->value() );
mySim->setCollisionCFM( myCollisionCFM->value() );
}
void EvolverUI::cb_Apply(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Apply_i(o,v);
}

void EvolverUI::cb_myDisplayRate_i(Fl_Value_Input*, void*) {
  myEvolver->setDisplayRate( (myDisplayRate->value()) );
}
void EvolverUI::cb_myDisplayRate(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myDisplayRate_i(o,v);
}

void EvolverUI::cb_myUpdateRate_i(Fl_Value_Input*, void*) {
  myEvolver->setUpdateRate( (myUpdateRate->value()) );
}
void EvolverUI::cb_myUpdateRate(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myUpdateRate_i(o,v);
}

void EvolverUI::cb_myInternalCollisions_i(Fl_Check_Button*, void*) {
  mySim->setAllowInternalCollisions( myInternalCollisions->value() == 1 );
}
void EvolverUI::cb_myInternalCollisions(Fl_Check_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myInternalCollisions_i(o,v);
}

void EvolverUI::cb_Walk_i(Fl_Menu_*, void*) {
  Else::FitnessFuncFactory lclFFFactory;

const char* name = "Walk";
myFitnessFunc
	= lclFFFactory.make( name );
std::cout << "Changing to fitness: " 
	  << name << "\n";
}
void EvolverUI::cb_Walk(Fl_Menu_* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Walk_i(o,v);
}

void EvolverUI::cb_Balance_i(Fl_Menu_*, void*) {
  Else::FitnessFuncFactory lclFFFactory;

const char* name = "Balance";
myFitnessFunc
	= lclFFFactory.make( name );
std::cout << "Changing to fitness: " 
	  << name << "\n";
}
void EvolverUI::cb_Balance(Fl_Menu_* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Balance_i(o,v);
}

void EvolverUI::cb_Constant_i(Fl_Menu_*, void*) {
  Else::FitnessFuncFactory lclFFFactory;

const char* name = "Constant";
myFitnessFunc
	= lclFFFactory.make( name );
std::cout << "Changing to fitness: " 
	  << name << "\n";
}
void EvolverUI::cb_Constant(Fl_Menu_* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Constant_i(o,v);
}

void EvolverUI::cb_Velocity_i(Fl_Menu_*, void*) {
  Else::FitnessFuncFactory lclFFFactory;

const char* name = "Velocity";
myFitnessFunc
	= lclFFFactory.make( name );
std::cout << "Changing to fitness: " 
	  << name << "\n";
}
void EvolverUI::cb_Velocity(Fl_Menu_* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Velocity_i(o,v);
}

Fl_Menu_Item EvolverUI::menu_myFitnessFuncChoice[] = {
 {"Walk", 0,  (Fl_Callback*)EvolverUI::cb_Walk, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Balance", 0,  (Fl_Callback*)EvolverUI::cb_Balance, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Constant", 0,  (Fl_Callback*)EvolverUI::cb_Constant, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Velocity", 0,  (Fl_Callback*)EvolverUI::cb_Velocity, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void EvolverUI::cb_Apply1_i(Fl_Button*, void*) {
  using namespace Else;
myFitnessFunc = myFitnessFunc;
updateParams();
}
void EvolverUI::cb_Apply1(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Apply1_i(o,v);
}

void EvolverUI::cb_Apply2_i(Fl_Button*, void*) {
  myFitnessFunc->setDoubleParam( myFitnessParamName->value(), myFitnessParamValue->value() );
}
void EvolverUI::cb_Apply2(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Apply2_i(o,v);
}

void EvolverUI::cb_Create_i(Fl_Button*, void*) {
  using namespace Else;

ArticulatedBody* b = 
	new ArticulatedBody( mySim->getWorldID(),
			     mySim->getSpaceID(),
			     myBodyHeight->value(), 
			     myBodyWeight->value() );

mySim->setBody( b );
}
void EvolverUI::cb_Create(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Create_i(o,v);
}

void EvolverUI::cb_myOverrideActuator1_i(Fl_Value_Slider*, void*) {
  if( myOverrideActuator1IsOn->value() == 1 )
{
	mySim->getBody()->manuallyOverrideActuator( myOverrideActuator1ID->value(), 
		myOverrideActuator1->value() );
};
}
void EvolverUI::cb_myOverrideActuator1(Fl_Value_Slider* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myOverrideActuator1_i(o,v);
}

void EvolverUI::cb_myOverrideActuator1ID_i(Fl_Value_Input*, void*) {
  if( myOverrideActuator1IsOn->value() == 1 )
{
	mySim->getBody()->manuallyOverrideActuator( myOverrideActuator1ID->value(), 
		myOverrideActuator1->value() );
} else
{
	mySim->getBody()->manuallyOverrideActuator( -1, 
		myOverrideActuator1->value() );
};
}
void EvolverUI::cb_myOverrideActuator1ID(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myOverrideActuator1ID_i(o,v);
}

void EvolverUI::cb_myOverrideActuator1IsOn_i(Fl_Check_Button*, void*) {
  if( myOverrideActuator1IsOn->value() == 1 )
{
	if( myOverrideActuator1ID->value() == -1 )
		myOverrideActuator1ID->value( 0 );
	mySim->getBody()->manuallyOverrideActuator( myOverrideActuator1ID->value(), 
		myOverrideActuator1->value() );
} else
{
	mySim->getBody()->manuallyOverrideActuator( -1, 
		myOverrideActuator1->value() );
};
}
void EvolverUI::cb_myOverrideActuator1IsOn(Fl_Check_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myOverrideActuator1IsOn_i(o,v);
}

void EvolverUI::cb_myForceScale_i(Fl_Value_Input*, void*) {
  mySim->getBody()->setForceScale( myForceScale->value() );
}
void EvolverUI::cb_myForceScale(Fl_Value_Input* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myForceScale_i(o,v);
}

void EvolverUI::cb_myHasController_i(Fl_Light_Button*, void*) {
  mySim->getBody()->setHasController( myHasController->value() == 1 );
}
void EvolverUI::cb_myHasController(Fl_Light_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myHasController_i(o,v);
}

void EvolverUI::cb_myAnimSaving_i(Fl_Light_Button*, void*) {
  if( myAnimSaving->value() == 1 )
{
  mySimWindow->saveAnim( myAnimName->value(), myCameraAngleChoice->value(), myPreviewToggle->value()  );
} else
{
  mySimWindow->stopAnim();
};
}
void EvolverUI::cb_myAnimSaving(Fl_Light_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_myAnimSaving_i(o,v);
}

Fl_Menu_Item EvolverUI::menu_myCameraAngleChoice[] = {
 {"Side-view", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Three-quarters walker", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Dramatic", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Original ELSE", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void EvolverUI::cb_Take_i(Fl_Button*, void*) {
  saveScreenImage( myStillName->value(), mySimWindow->w(), mySimWindow->h() );
}
void EvolverUI::cb_Take(Fl_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->parent()->parent()->parent()->user_data()))->cb_Take_i(o,v);
}

void EvolverUI::cb_myShowSim_i(Fl_Light_Button*, void*) {
  mySimWindow->enable( 1 == myShowSim->value() );
}
void EvolverUI::cb_myShowSim(Fl_Light_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->user_data()))->cb_myShowSim_i(o,v);
}

void EvolverUI::cb_Start_i(Fl_Return_Button*, void*) {
  using namespace Else;

if( !(myNeat->is_ready) )
{
  const char* filename 
	= fl_file_chooser( "Select a NEAT Configuration file.",
			   "*.ne", NULL, 0 );
  myNeat->is_ready 
	= myNeat->load_neat_params( (char*) filename );
}

// Second Try
if( myNeat->is_ready )
{
  if( myEvolver->isRunning() ) 
  {
    myEvolver->toggleRunning();
  } else {
    myEvolver->go( myNeat->pop_size, myGenLimit->value(), myFitnessFunc, mySim, myGenotypeFilename->value(), mySingleRunHasHarness->value()  );
  }
} else {
  fl_message( "Can't start NEAT evoluation without initializing NEAT params." );
};
}
void EvolverUI::cb_Start(Fl_Return_Button* o, void* v) {
  ((EvolverUI*)(o->parent()->parent()->parent()->user_data()))->cb_Start_i(o,v);
}

EvolverUI::EvolverUI() {
std::cerr << "EvolverUI Ctor\n";
  { myWindow = new Fl_Double_Window(615, 535, "ELSE");
std::cerr << "EvolverUI Ctor - Creating Window\n";
    myWindow->user_data((void*)(this));
    { myMenuBar = new Fl_Menu_Bar(0, 0, 620, 20);
      myMenuBar->labelsize(12);
      myMenuBar->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      myMenuBar->menu(menu_myMenuBar);
    } // Fl_Menu_Bar* myMenuBar
std::cerr << "EvolverUI Ctor - Creating Title\n";
    { Fl_Tile* o = new Fl_Tile(-20, 20, 720, 510);
      o->labeltype(FL_NO_LABEL);
      o->align(FL_ALIGN_CENTER);
      { Fl_Group* o = new Fl_Group(-20, 20, 360, 460);
        o->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
std::cerr << "EvolverUI Ctor - Creating Sim Window\n";
        { mySimWindow = new Else::SimulationWindow(0, 20, 320, 440);
std::cerr << "EvolverUI Ctor - Done creating Sim Window\n";
	
          mySimWindow->box(FL_THIN_UP_FRAME);
          mySimWindow->color(FL_BACKGROUND_COLOR);
          mySimWindow->selection_color(FL_BACKGROUND_COLOR);
          mySimWindow->labeltype(FL_NO_LABEL);
          mySimWindow->labelfont(0);
          mySimWindow->labelsize(14);
          mySimWindow->labelcolor(FL_FOREGROUND_COLOR);
          mySimWindow->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
          mySimWindow->when(FL_WHEN_RELEASE);
          Fl_Group::current()->resizable(mySimWindow);
        } // Else::SimulationWindow* mySimWindow
        { myCameraElevationSlider = new Fl_Roller(320, 20, 20, 440);
          myCameraElevationSlider->minimum(-180);
          myCameraElevationSlider->maximum(180);
          myCameraElevationSlider->step(1);
          myCameraElevationSlider->value(30);
          myCameraElevationSlider->callback((Fl_Callback*)cb_myCameraElevationSlider);
          myCameraElevationSlider->align(FL_ALIGN_CENTER);
        } // Fl_Roller* myCameraElevationSlider
        { myCameraRotationSlider = new Fl_Roller(-20, 460, 360, 20);
          myCameraRotationSlider->type(1);
          myCameraRotationSlider->minimum(-180);
          myCameraRotationSlider->maximum(180);
          myCameraRotationSlider->step(1);
          myCameraRotationSlider->callback((Fl_Callback*)cb_myCameraRotationSlider);
          myCameraRotationSlider->align(FL_ALIGN_CENTER);
        } // Fl_Roller* myCameraRotationSlider
        o->end();
        Fl_Group::current()->resizable(o);
      } // Fl_Group* o

	std::cerr << "EvolverUI Ctor  - A\n";

      { Fl_Pack* o = new Fl_Pack(340, 20, 270, 510);
        o->type(1);
        o->box(FL_THIN_UP_FRAME);
        { Fl_Tabs* o = new Fl_Tabs(340, 20, 270, 510);
          { myNeatParamsGroup = new Fl_Group(340, 40, 270, 490, "Evolution");
            myNeatParamsGroup->labelsize(12);
            myNeatParamsGroup->when(FL_WHEN_NEVER);
            { Fl_Scroll* o = new Fl_Scroll(340, 40, 270, 490);
              o->type(2);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_NEVER);
              { Fl_Group* o = new Fl_Group(340, 40, 270, 490);
                o->labelsize(12);
                { Fl_Group* o = new Fl_Group(350, 60, 230, 120, "General");
                o->box(FL_PLASTIC_DOWN_BOX);
                o->align(FL_ALIGN_TOP_LEFT);
                { myNumRuns = new Fl_Value_Input(510, 70, 60, 20, "Number of Runs:");
                myNumRuns->tooltip("Sets the upper-bound on the number of generations to evaluate");
                myNumRuns->labelsize(12);
                myNumRuns->value(1);
                myNumRuns->textsize(12);
                myNumRuns->callback((Fl_Callback*)cb_myNumRuns);
                } // Fl_Value_Input* myNumRuns
                { myGenLimit = new Fl_Value_Input(510, 90, 60, 20, "Generations:");
                myGenLimit->tooltip("Sets the upper-bound on the number of generations to evaluate");
                myGenLimit->labelsize(12);
                myGenLimit->value(200);
                myGenLimit->textsize(12);
                } // Fl_Value_Input* myGenLimit
                { myPopSize = new Fl_Value_Input(510, 110, 60, 20, "Population Size:");
                myPopSize->tooltip("The number of organisms in a population. Must be divisible by 4 for Echo Stat\
e Nets");
                myPopSize->labelsize(12);
                myPopSize->value(80);
                myPopSize->textsize(12);
                myPopSize->callback((Fl_Callback*)cb_myPopSize);
                } // Fl_Value_Input* myPopSize
                { myStepCount = new Fl_Value_Input(510, 130, 60, 20, "Max Time Steps per Eval:");
                myStepCount->tooltip("The number of organisms in a population.");
                myStepCount->labelsize(12);
                myStepCount->maximum(1e+07);
                myStepCount->step(1);
                myStepCount->value(10000);
                myStepCount->textsize(12);
                myStepCount->deactivate();
                Fl_Group::current()->resizable(myStepCount);
                } // Fl_Value_Input* myStepCount
                { myRandSeed = new Fl_Value_Input(510, 150, 60, 20, "Random Seed:");
                myRandSeed->labelsize(12);
                myRandSeed->textsize(12);
                myRandSeed->callback((Fl_Callback*)cb_myRandSeed);
                } // Fl_Value_Input* myRandSeed
                o->end();
                } // Fl_Group* o
                { Fl_Button* o = new Fl_Button(425, 395, 150, 20, "Set Initial Genotype File...");
                o->labelsize(12);
                o->callback((Fl_Callback*)cb_Set);
                } // Fl_Button* o
                { myGenotypeFilename = new Fl_Output(360, 370, 210, 20, "Initial Genotype Filename:");
                myGenotypeFilename->color(FL_DARK1);
                myGenotypeFilename->labelsize(12);
                myGenotypeFilename->textsize(12);
                myGenotypeFilename->align(FL_ALIGN_TOP_LEFT);
                } // Fl_Output* myGenotypeFilename
                { Fl_Group* o = new Fl_Group(350, 460, 230, 60, "Fitness Progress");
                o->box(FL_PLASTIC_DOWN_BOX);
                o->labelsize(12);
                o->align(FL_ALIGN_TOP_LEFT);
                { myFitnessGraph = new Else::FitnessGraph(350, 460, 230, 60);
                myFitnessGraph->box(FL_PLASTIC_UP_FRAME);
                myFitnessGraph->color(FL_BACKGROUND_COLOR);
                myFitnessGraph->selection_color(FL_BACKGROUND_COLOR);
                myFitnessGraph->labeltype(FL_NORMAL_LABEL);
                myFitnessGraph->labelfont(0);
                myFitnessGraph->labelsize(14);
                myFitnessGraph->labelcolor(FL_FOREGROUND_COLOR);
                myFitnessGraph->align(FL_ALIGN_CENTER);
                myFitnessGraph->when(FL_WHEN_RELEASE);
                } // Else::FitnessGraph* myFitnessGraph
                o->end();
                } // Fl_Group* o
                { myRunStraightSim = new Fl_Button(425, 420, 150, 20, "Run Sim with Genotype");
                myRunStraightSim->labelsize(12);
                myRunStraightSim->callback((Fl_Callback*)cb_myRunStraightSim);
                myRunStraightSim->deactivate();
                } // Fl_Button* myRunStraightSim
                { myControllerChoice = new Fl_Choice(440, 185, 140, 20, "Controller Type:");
                myControllerChoice->down_box(FL_BORDER_BOX);
                myControllerChoice->labelsize(12);
                myControllerChoice->textsize(12);
                myControllerChoice->callback((Fl_Callback*)cb_myControllerChoice);
                myControllerChoice->menu(menu_myControllerChoice);
                } // Fl_Choice* myControllerChoice
                { mySingleRunHasHarness = new Fl_Light_Button(350, 420, 72, 20, "w/o Harness");
                mySingleRunHasHarness->labelsize(10);
                } // Fl_Light_Button* mySingleRunHasHarness
                { Fl_Tabs* o = new Fl_Tabs(350, 210, 250, 140);
                { Fl_Group* o = new Fl_Group(350, 230, 250, 120, "NEAT");
                o->box(FL_PLASTIC_DOWN_BOX);
                { myDropOffAge = new Fl_Value_Input(530, 240, 60, 20, "Species Drop-off Age:");
                myDropOffAge->tooltip("Age of species where they begin to be penalized for just being old.");
                myDropOffAge->labelsize(12);
                myDropOffAge->value(10);
                myDropOffAge->textsize(12);
                myDropOffAge->callback((Fl_Callback*)cb_myDropOffAge);
                } // Fl_Value_Input* myDropOffAge
                { myMutationWeight = new Fl_Value_Input(530, 266, 60, 20, "Link-weight Mutation:");
                myMutationWeight->tooltip("The strength of link-weight mutations.");
                myMutationWeight->labelsize(12);
                myMutationWeight->value(10);
                myMutationWeight->textsize(12);
                myMutationWeight->callback((Fl_Callback*)cb_myMutationWeight);
                Fl_Group::current()->resizable(myMutationWeight);
                } // Fl_Value_Input* myMutationWeight
                { mySpeciesTarget = new Fl_Value_Input(530, 293, 60, 20, "Target Species Count:");
                mySpeciesTarget->tooltip("The species threshold will change to maintain this # of species");
                mySpeciesTarget->labelsize(12);
                mySpeciesTarget->value(20);
                mySpeciesTarget->textsize(12);
                mySpeciesTarget->callback((Fl_Callback*)cb_mySpeciesTarget);
                } // Fl_Value_Input* mySpeciesTarget
                { myLinkWeightMutationProb = new Fl_Value_Input(530, 320, 60, 20, "Prob of Link Wt Mutatation:");
                myLinkWeightMutationProb->tooltip("The chance of non-structurally changed mutations will modify link weight.");
                myLinkWeightMutationProb->labelsize(12);
                myLinkWeightMutationProb->step(0.01);
                myLinkWeightMutationProb->value(0.1);
                myLinkWeightMutationProb->textsize(12);
                myLinkWeightMutationProb->callback((Fl_Callback*)cb_myLinkWeightMutationProb);
                } // Fl_Value_Input* myLinkWeightMutationProb
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(370, 230, 230, 120, "ESN");
                o->hide();
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Tabs* o
                o->end();
              } // Fl_Group* o
              o->end();
              Fl_Group::current()->resizable(o);
            } // Fl_Scroll* o
            myNeatParamsGroup->end();
          } // Fl_Group* myNeatParamsGroup

		std::cerr << "EvolverUI Ctor  - B\n";

          { myPhysicsGroup = new Fl_Group(340, 40, 270, 490, "Physics");
            myPhysicsGroup->labelsize(12);
            myPhysicsGroup->hide();
            { myGravity = new Fl_Value_Input(360, 60, 230, 20, "Gravity:");
              myGravity->labelsize(12);
              myGravity->minimum(-20);
              myGravity->maximum(20);
              myGravity->value(-9.8);
              myGravity->textsize(12);
              myGravity->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myGravity
            { myCFM = new Fl_Value_Input(360, 100, 230, 20, "Constraint Force Mixing (CFM):");
              myCFM->tooltip("Zero is for normal, hard constraints.  Softness goes up with CFM");
              myCFM->labelsize(12);
              myCFM->maximum(2);
              myCFM->textsize(12);
              myCFM->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myCFM
            { myERP = new Fl_Value_Input(360, 140, 230, 20, "Error Reduction Parameter (ERP):");
              myERP->tooltip("Fraction of the error in joints to be fixed per time step.  Defaults to 0.2");
              myERP->labelsize(12);
              myERP->value(0.2);
              myERP->textsize(12);
              myERP->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myERP
            { myFastStepToggle = new Fl_Check_Button(360, 240, 230, 20, "Use Fast (Inaccurate) Step");
              myFastStepToggle->down_box(FL_DOWN_BOX);
              myFastStepToggle->value(1);
              myFastStepToggle->labelsize(12);
            } // Fl_Check_Button* myFastStepToggle
            { Fl_Button* o = new Fl_Button(450, 350, 140, 30, "Apply Physics Settings");
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_Apply);
            } // Fl_Button* o
            { myTimeStep = new Fl_Value_Input(360, 180, 230, 20, "Time Step");
              myTimeStep->labelsize(12);
              myTimeStep->value(0.0025);
              myTimeStep->textsize(12);
              myTimeStep->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myTimeStep
            { myDisplayRate = new Fl_Value_Input(360, 410, 230, 20, "Display Rate:");
              myDisplayRate->labelsize(12);
              myDisplayRate->maximum(10000);
              myDisplayRate->step(1);
              myDisplayRate->value(1);
              myDisplayRate->textsize(12);
              myDisplayRate->callback((Fl_Callback*)cb_myDisplayRate);
              myDisplayRate->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myDisplayRate
            { myUpdateRate = new Fl_Value_Input(360, 450, 230, 20, "Controller Evaluation Rate (per Physics):");
              myUpdateRate->labelsize(12);
              myUpdateRate->maximum(10000);
              myUpdateRate->step(1);
              myUpdateRate->value(5);
              myUpdateRate->textsize(12);
              myUpdateRate->callback((Fl_Callback*)cb_myUpdateRate);
              myUpdateRate->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myUpdateRate
            { myFastSubSteps = new Fl_Value_Input(360, 220, 230, 20, "Fast Time Sub-Steps");
              myFastSubSteps->labelsize(12);
              myFastSubSteps->minimum(1);
              myFastSubSteps->maximum(500);
              myFastSubSteps->step(1);
              myFastSubSteps->value(25);
              myFastSubSteps->textsize(12);
              myFastSubSteps->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myFastSubSteps
            { myInternalCollisions = new Fl_Check_Button(360, 480, 230, 20, "Check for Intra-body Collisions");
              myInternalCollisions->down_box(FL_DOWN_BOX);
              myInternalCollisions->labelsize(12);
              myInternalCollisions->callback((Fl_Callback*)cb_myInternalCollisions);
            } // Fl_Check_Button* myInternalCollisions
            { myCollisionERP = new Fl_Value_Input(360, 280, 230, 20, "Collision ERP:");
              myCollisionERP->labelsize(12);
              myCollisionERP->step(0.1);
              myCollisionERP->value(0.8);
              myCollisionERP->textsize(12);
              myCollisionERP->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myCollisionERP
            { myCollisionCFM = new Fl_Value_Input(360, 320, 230, 20, "Collision CFM:");
              myCollisionCFM->labelsize(12);
              myCollisionCFM->step(1e-07);
              myCollisionCFM->value(0.0001);
              myCollisionCFM->textsize(12);
              myCollisionCFM->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Input* myCollisionCFM
            myPhysicsGroup->end();
          } // Fl_Group* myPhysicsGroup

		std::cerr << "EvolverUI Ctor  - C\n";

          { myFitnessFunctionGroup = new Fl_Group(340, 40, 270, 480, "Fitness");
            myFitnessFunctionGroup->labelsize(12);
            myFitnessFunctionGroup->hide();
            { myFitnessFuncChoice = new Fl_Choice(370, 65, 220, 20, "Base Fitness Function:");
              myFitnessFuncChoice->down_box(FL_BORDER_BOX);
              myFitnessFuncChoice->labelsize(12);
              myFitnessFuncChoice->textsize(12);
              myFitnessFuncChoice->align(FL_ALIGN_TOP_LEFT);
              myFitnessFuncChoice->menu(menu_myFitnessFuncChoice);
            } // Fl_Choice* myFitnessFuncChoice
            { Fl_Button* o = new Fl_Button(430, 100, 160, 40, "Apply Fitness Function (Force Reset)");
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_Apply1);
              o->align(FL_ALIGN_WRAP);
            } // Fl_Button* o
            { myFitnessParamValue = new Fl_Value_Input(470, 190, 120, 20, "Parameter Value:");
              myFitnessParamValue->labelsize(12);
              myFitnessParamValue->textsize(12);
            } // Fl_Value_Input* myFitnessParamValue
            { myFitnessParamName = new Fl_Input(470, 160, 120, 20, "Parameter Name:");
              myFitnessParamName->labelsize(12);
              myFitnessParamName->textsize(12);
            } // Fl_Input* myFitnessParamName
            { Fl_Button* o = new Fl_Button(430, 220, 160, 30, "Apply Fitness Parameter");
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_Apply2);
            } // Fl_Button* o
            { myFitnessInstructions = new Fl_Text_Display(370, 260, 220, 150);
              myFitnessInstructions->labelsize(12);
              myFitnessInstructions->textsize(10);
            } // Fl_Text_Display* myFitnessInstructions
            myFitnessFunctionGroup->end();
          } // Fl_Group* myFitnessFunctionGroup
          { myBodyParamsGroup = new Fl_Group(340, 40, 270, 480, "Body");
            myBodyParamsGroup->labelsize(12);
            myBodyParamsGroup->hide();
            { myBodyHeight = new Fl_Value_Input(500, 60, 90, 20, "Height (m):");
              myBodyHeight->tooltip("Sets the height of the body to generate (in meters).");
              myBodyHeight->labelsize(12);
              myBodyHeight->value(1.75);
              myBodyHeight->textsize(12);
            } // Fl_Value_Input* myBodyHeight
            { myBodyWeight = new Fl_Value_Input(500, 88, 90, 20, "Weight Factor (kg/kg):");
              myBodyWeight->tooltip("Ratio of kilograms to simiulated kilograms.");
              myBodyWeight->labelsize(12);
              myBodyWeight->value(1);
              myBodyWeight->textsize(12);
            } // Fl_Value_Input* myBodyWeight
            { Fl_Button* o = new Fl_Button(480, 110, 110, 50, "Create New Body (Sim not Running!)");
              o->tooltip("Will only have an effect on the next evolutionary run.");
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_Create);
              o->align(FL_ALIGN_WRAP);
            } // Fl_Button* o
            { myOverrideActuator1 = new Fl_Value_Slider(380, 210, 190, 20);
              myOverrideActuator1->type(5);
              myOverrideActuator1->labelsize(12);
              myOverrideActuator1->callback((Fl_Callback*)cb_myOverrideActuator1);
              myOverrideActuator1->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Value_Slider* myOverrideActuator1
            { myOverrideActuator1ID = new Fl_Value_Input(570, 210, 30, 20, "Actuator #:");
              myOverrideActuator1ID->tooltip("-1 To have no effect.");
              myOverrideActuator1ID->labelsize(12);
              myOverrideActuator1ID->minimum(-1);
              myOverrideActuator1ID->maximum(12);
              myOverrideActuator1ID->step(1);
              myOverrideActuator1ID->value(-1);
              myOverrideActuator1ID->textsize(12);
              myOverrideActuator1ID->callback((Fl_Callback*)cb_myOverrideActuator1ID);
              myOverrideActuator1ID->align(FL_ALIGN_TOP_RIGHT);
            } // Fl_Value_Input* myOverrideActuator1ID
            { myOverrideActuator1IsOn = new Fl_Check_Button(360, 210, 20, 20, "Manually Override Actuator");
              myOverrideActuator1IsOn->down_box(FL_DOWN_BOX);
              myOverrideActuator1IsOn->labelsize(12);
              myOverrideActuator1IsOn->callback((Fl_Callback*)cb_myOverrideActuator1IsOn);
              myOverrideActuator1IsOn->align(FL_ALIGN_TOP_LEFT);
            } // Fl_Check_Button* myOverrideActuator1IsOn
            { myForceScale = new Fl_Value_Input(510, 250, 80, 20, "Force Scale:");
              myForceScale->labelsize(12);
              myForceScale->maximum(100000);
              myForceScale->value(10000);
              myForceScale->textsize(12);
              myForceScale->callback((Fl_Callback*)cb_myForceScale);
            } // Fl_Value_Input* myForceScale
            { myHasController = new Fl_Light_Button(470, 290, 120, 30, "Engage Controller");
              myHasController->value(1);
              myHasController->labelsize(12);
              myHasController->callback((Fl_Callback*)cb_myHasController);
            } // Fl_Light_Button* myHasController
std::cerr << "EvolverUI Ctor  - D\n";
            { Fl_Group* o = new Fl_Group(350, 410, 260, 110);
              { myLeftActuatorOutput1 = new Fl_Progress(360, 440, 110, 20);
                myLeftActuatorOutput1->box(FL_PLASTIC_THIN_UP_BOX);
                myLeftActuatorOutput1->selection_color((Fl_Color)29);
                myLeftActuatorOutput1->labelsize(10);
                myLeftActuatorOutput1->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
                myLeftActuatorOutput1->when(FL_WHEN_CHANGED);
              } // Fl_Progress* myLeftActuatorOutput1
              { myLeftActuatorOutput2 = new Fl_Progress(360, 470, 110, 20);
                myLeftActuatorOutput2->box(FL_PLASTIC_THIN_UP_BOX);
                myLeftActuatorOutput2->selection_color((Fl_Color)29);
                myLeftActuatorOutput2->labelsize(10);
              } // Fl_Progress* myLeftActuatorOutput2
              { myLeftActuatorOutput3 = new Fl_Progress(360, 500, 110, 20);
                myLeftActuatorOutput3->box(FL_PLASTIC_THIN_UP_BOX);
                myLeftActuatorOutput3->selection_color((Fl_Color)29);
                myLeftActuatorOutput3->labelsize(10);
              } // Fl_Progress* myLeftActuatorOutput3
              { myRightActuatorOutput1 = new Fl_Progress(490, 440, 110, 20);
                myRightActuatorOutput1->box(FL_PLASTIC_THIN_UP_BOX);
                myRightActuatorOutput1->selection_color((Fl_Color)29);
                myRightActuatorOutput1->labelsize(10);
              } // Fl_Progress* myRightActuatorOutput1
              { myRightActuatorOutput2 = new Fl_Progress(490, 470, 110, 20);
                myRightActuatorOutput2->box(FL_PLASTIC_THIN_UP_BOX);
                myRightActuatorOutput2->selection_color((Fl_Color)29);
                myRightActuatorOutput2->labelsize(10);
              } // Fl_Progress* myRightActuatorOutput2
              { myRightActuatorOutput3 = new Fl_Progress(490, 500, 110, 20);
                myRightActuatorOutput3->box(FL_PLASTIC_THIN_UP_BOX);
                myRightActuatorOutput3->selection_color((Fl_Color)29);
                myRightActuatorOutput3->labelsize(10);
              } // Fl_Progress* myRightActuatorOutput3
              { Fl_Text_Display* o = new Fl_Text_Display(500, 430, 90, 0, "Right (Knee, HipX, HipZ)");
                o->labelsize(10);
                o->textsize(12);
              } // Fl_Text_Display* o
              { Fl_Text_Display* o = new Fl_Text_Display(370, 430, 90, 0, "Left (Knee, HipX, HipZ)");
                o->labelsize(10);
                o->textsize(12);
              } // Fl_Text_Display* o
              o->end();
            } // Fl_Group* o
            myBodyParamsGroup->end();
          } // Fl_Group* myBodyParamsGroup
std::cerr << "EvolverUI Ctor  - E\n";
          { Images = new Fl_Group(340, 40, 270, 490, "Images");
            Images->labelsize(12);
            Images->hide();
            { Fl_Group* o = new Fl_Group(350, 80, 250, 165, "Animation Recording");
              o->box(FL_PLASTIC_THIN_DOWN_BOX);
              o->align(FL_ALIGN_TOP_LEFT);
              { myAnimSaving = new Fl_Light_Button(440, 205, 150, 30, "Save Animation to Disk");
                myAnimSaving->labelsize(12);
                myAnimSaving->callback((Fl_Callback*)cb_myAnimSaving);
              } // Fl_Light_Button* myAnimSaving
              { myAnimName = new Fl_Input(370, 100, 220, 20, "Prefix for animation files:");
                myAnimName->labelsize(12);
                myAnimName->textsize(12);
                myAnimName->align(FL_ALIGN_TOP_LEFT);
              } // Fl_Input* myAnimName
              { myPreviewToggle = new Fl_Check_Button(445, 125, 64, 15, "Preview");
                myPreviewToggle->down_box(FL_DOWN_BOX);
                myPreviewToggle->labelsize(12);
              } // Fl_Check_Button* myPreviewToggle
              { myCameraAngleChoice = new Fl_Choice(445, 160, 145, 20, "Camera Angle:");
                myCameraAngleChoice->down_box(FL_BORDER_BOX);
                myCameraAngleChoice->labelsize(12);
                myCameraAngleChoice->textsize(12);
                myCameraAngleChoice->align(FL_ALIGN_TOP_LEFT);
                myCameraAngleChoice->menu(menu_myCameraAngleChoice);
              } // Fl_Choice* myCameraAngleChoice
              o->end();
            } // Fl_Group* o
            { Fl_Group* o = new Fl_Group(350, 420, 250, 90, "Screen Shots");
              o->box(FL_PLASTIC_THIN_DOWN_BOX);
              o->align(FL_ALIGN_TOP_LEFT);
              { myStillName = new Fl_Input(370, 440, 220, 20, "Prefix for still image file:");
                myStillName->labelsize(12);
                myStillName->textsize(12);
                myStillName->align(FL_ALIGN_TOP_LEFT);
              } // Fl_Input* myStillName
              { Fl_Button* o = new Fl_Button(480, 470, 110, 30, "Take Screenshot");
                o->labelsize(12);
                o->callback((Fl_Callback*)cb_Take);
              } // Fl_Button* o
              o->end();
            } // Fl_Group* o
            Images->end();
          } // Fl_Group* Images
          o->end();
        } // Fl_Tabs* o
        o->end();
      } // Fl_Pack* o
std::cerr << "EvolverUI Ctor  - F\n";

      { Fl_Group* o = new Fl_Group(0, 480, 340, 50);
        o->box(FL_THIN_UP_FRAME);
        o->align(FL_ALIGN_BOTTOM_LEFT|FL_ALIGN_INSIDE);
        { myShowSim = new Fl_Light_Button(10, 490, 150, 30, "Show Simulation");
          myShowSim->value(1);
          myShowSim->callback((Fl_Callback*)cb_myShowSim);
          myShowSim->align(FL_ALIGN_WRAP|FL_ALIGN_INSIDE);
          myShowSim->when(FL_WHEN_CHANGED);
        } // Fl_Light_Button* myShowSim
        { Fl_Return_Button* o = new Fl_Return_Button(170, 490, 160, 30, "Start Evolution");
          o->callback((Fl_Callback*)cb_Start);
          o->align(FL_ALIGN_WRAP);
        } // Fl_Return_Button* o
        o->end();
      } // Fl_Group* o
      o->end();
    } // Fl_Tile* o
    myWindow->end();
    myWindow->resizable(myWindow);
  } // Fl_Double_Window* myWindow
std::cerr << "EvolverUI Ctor  - Done building windows\n";
  // Setup the Initial State
using namespace Else;
std::cerr << "EvolverUI Ctor  - Setup Simulation\n";
	myForceScale->value( DEFAULT_FORCE_SCALE );
	myTimeStep->value( DEFAULT_TIME_STEP );
	myFastSubSteps->value( DEFAULT_TIME_SUBSTEPS );
	mySim = PhysicsSimulatorPtr( new PhysicsSimulator() );
std::cerr << "EvolverUI Ctor  - Creat Articulated Body\n";
	ArticulatedBody* lclBody 
		= new ArticulatedBody( mySim->getWorldID(), mySim->getSpaceID() );
	mySim->setBody( lclBody );
	mySimWindow->setSim( mySim );
	int currTime = time( NULL );
	myRandSeed->value( currTime );
	srand( currTime );

std::cerr << "EvolverUI Ctor  - Creat NEAT\n";

	myNeat = new NEAT();
	std::string filename( "data/default.ne" );
	std::ifstream testFile( filename.c_str() );
	if( testFile ) {
		myNeat->load_neat_params( filename.c_str() );
	}

std::cerr << "EvolverUI Ctor  - Creat Fitness Factory\n";

	FitnessFuncFactory lclFFFactory;
	myFitnessFunc = FitnessFuncPtr( lclFFFactory.make( "Walk" ) );
	myEvolver = EvolverPtr( new NeatEvolver( myNeat ) );
	myFitnessGraph->setFitness( myFitnessFunc );
	myFitnessGraph->setTotalGenerations( myGenLimit->value() );
	updateParams();

myFitnessInstructionBuffer = new Fl_Text_Buffer();
myFitnessInstructions->buffer( myFitnessInstructionBuffer );
myFitnessInstructionBuffer->text(
"Height\t\tSets the minimum allowed height in meters\n" \
"TimeValue\t\tThe fitness value for just still being around.  Defaults to 0.1\n" \
"HarnessHeight\t\tSets the minimum height before harness kicks in." );

myLeftActuatorOutput1->minimum( -1 );
myLeftActuatorOutput1->maximum(  1 );
myLeftActuatorOutput2->minimum( -1 );
myLeftActuatorOutput2->maximum(  1 );
myLeftActuatorOutput3->minimum( -1 );
myLeftActuatorOutput3->maximum(  1 );

myRightActuatorOutput1->minimum( -1 );
myRightActuatorOutput1->maximum(  1 );
myRightActuatorOutput2->minimum( -1 );
myRightActuatorOutput2->maximum(  1 );
myRightActuatorOutput3->minimum( -1 );
myRightActuatorOutput3->maximum(  1 );

std::cerr << "EvolverUI Ctor  - DONE\n";

}

void EvolverUI::show( int argc, char* argv[] ) {
  myWindow->show();
}

void EvolverUI::updateParams() {
  // Sync display to main program
myNumRuns->value( myNeat->num_runs );
myPopSize->value( myNeat->pop_size );
myDropOffAge->value( myNeat->dropoff_age );
mySpeciesTarget->value( myNeat->num_species_target );
myLinkWeightMutationProb->value( myNeat->mutate_link_weights_prob );
myMutationWeight->value( myNeat->weight_mut_power );
myUpdateRate->value( myEvolver->getUpdateRate() );
myDisplayRate->value( myEvolver->getDisplayRate() );
myTimeStep->value( mySim->getTimeStep() );
myFastSubSteps->value( mySim->getFastSubSteps() );
myFastStepToggle->value( mySim->getUseFastStep() ? 1 : 0 );
myInternalCollisions->value( mySim->getAllowInternalCollisions() ? 1 : 0 );
myCFM->value( mySim->getCFM() );
myERP->value( mySim->getERP() );
myGravity->value( mySim->getGravity() );
myCollisionCFM->value( mySim->getCollisionCFM() );
myCollisionERP->value( mySim->getCollisionERP() );
}

void EvolverUI::showActuators( const std::vector<double>& argActuators ) {
  assert( argActuators.size() >= 6 );

setActuator( myRightActuatorOutput1, argActuators[0], 0 );
setActuator( myRightActuatorOutput2, argActuators[1], 1 );
setActuator( myRightActuatorOutput3, argActuators[2], 2 );

setActuator( myLeftActuatorOutput1, argActuators[3], 3 );
setActuator( myLeftActuatorOutput2, argActuators[4], 4 );
setActuator( myLeftActuatorOutput3, argActuators[5], 5 );
}

void EvolverUI::setActuator( Fl_Progress* argProg, double argValue, int argId ) {
  sprintf( myActuatorLabel[argId], "%1.3f\0", argValue );
argProg->label( myActuatorLabel[argId] );
argProg->value( argValue );
}
